name: iOS CI - Build and TestFlight

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build-and-upload:
    runs-on: macos-latest
    env:
      MATCH_GIT_URL: ${{ vars.MATCH_GIT_URL }}
+      MATCH_GIT_URL_SECRET: ${{ secrets.MATCH_GIT_URL }}
      MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      TEAM_ID: ${{ secrets.TEAM_ID }}
      APP_IDENTIFIER: ${{ secrets.APP_IDENTIFIER }}
      APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
      APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      APP_STORE_CONNECT_KEY: ${{ secrets.APP_STORE_CONNECT_KEY }}
      # Optional auth mechanisms for private match repo
      MATCH_GIT_PRIVATE_KEY: ${{ secrets.MATCH_GIT_PRIVATE_KEY }}
      MATCH_GIT_PRIVATE_KEY_B64: ${{ secrets.MATCH_GIT_PRIVATE_KEY_B64 }}
      MATCH_READONLY: ${{ secrets.MATCH_READONLY }}
      FASTLANE_SKIP_UPDATE_CHECK: true
      FASTLANE_VERBOSE: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Install Homebrew dependencies
        run: |
          brew update
          brew install xcodegen

      - name: Generate Xcode project
        run: xcodegen generate

      - name: Show Xcode version
        run: xcodebuild -version

      - name: Install gems
        run: bundle install --path vendor/bundle

      - name: Configure Git auth for match repo (HTTPS token)
        if: ${{ env.MATCH_GIT_TOKEN != '' }}
        run: |
          git config --global url."https://${{ env.MATCH_GIT_TOKEN }}@github.com/".insteadOf "https://github.com/"

      - name: Prepare SSH key from secret
        if: ${{ env.MATCH_GIT_PRIVATE_KEY != '' || env.MATCH_GIT_PRIVATE_KEY_B64 != '' }}
        id: prep_match_key
        shell: bash
        run: |
          # Prefer base64 secret if provided to avoid newline/encoding issues
          if [ -n "${{ env.MATCH_GIT_PRIVATE_KEY_B64 }}" ]; then
            echo "Using base64-encoded private key secret"
            KEY="$(echo "${{ env.MATCH_GIT_PRIVATE_KEY_B64 }}" | base64 --decode | LC_ALL=C tr -d '\r')"
          else
            KEY="${{ env.MATCH_GIT_PRIVATE_KEY }}"
            # If the secret is single-line with literal \n, convert to real newlines
            if echo "$KEY" | grep -q '\\n'; then
              KEY="$(printf "%b" "$KEY")"
            fi
            # Normalize Windows CRLF to LF (force C locale to avoid encoding issues)
            KEY="$(echo "$KEY" | LC_ALL=C tr -d '\r')"
            # If header missing, try base64-decode fallback
            if ! echo "$KEY" | grep -Eq 'BEGIN (OPENSSH|RSA) PRIVATE KEY'; then
              if echo "$KEY" | base64 --decode > /tmp/match_key_decoded 2>/dev/null; then
                # Use LC_ALL=C to avoid illegal byte sequence errors
                KEY="$(cat /tmp/match_key_decoded | LC_ALL=C tr -d '\r')"
              else
                echo 'Note: Private key header missing and base64 decode failed. Ensure the secret contains the FULL private key.'
              fi
            fi
          fi

          # Reject PuTTY .ppk format explicitly
          if echo "$KEY" | head -n1 | grep -q 'PuTTY-User-Key-File-'; then
            echo 'Error: Detected PuTTY .ppk format. Export OpenSSH private key via PuTTYgen (Conversions â†’ Export OpenSSH key (new)).'
            exit 1
          fi

          # Log detected key header type (no secret content is printed)
          if echo "$KEY" | grep -q 'BEGIN OPENSSH PRIVATE KEY'; then
            echo 'Detected OpenSSH private key.'
          elif echo "$KEY" | grep -q 'BEGIN RSA PRIVATE KEY'; then
            echo 'Detected PEM RSA private key.'
          else
            echo 'Warning: No recognized private key header found.'
          fi

          # Emit processed key as output (multi-line)
          {
            echo 'key<<EOF'
            echo "$KEY"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Start ssh-agent and add match deploy key
        if: ${{ env.MATCH_GIT_PRIVATE_KEY != '' || env.MATCH_GIT_PRIVATE_KEY_B64 != '' }}
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ steps.prep_match_key.outputs.key }}

      - name: Add GitHub to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          echo "SSH agent ready; using $MATCH_GIT_URL"

      - name: "Preflight: verify certs repo access and readonly mode"
        shell: bash
        run: |
          readonly_flag="${MATCH_READONLY:-true}"
          echo "Match readonly: ${readonly_flag}"

          # Force SSH-only auth if a private key is provided; ignore token
          auth_mode="ssh"
          echo "Preflight auth mode: ${auth_mode}"

          # Sanitize MATCH_GIT_URL (strip CR, surrounding whitespace, stray quotes/backticks)
          effective_url_raw="${MATCH_GIT_URL}"
+          effective_url_raw="${MATCH_GIT_URL}"
+          if [ -z "${effective_url_raw}" ]; then
+            effective_url_raw="${MATCH_GIT_URL_SECRET}"
+          fi
           effective_url="$(printf "%s" "${effective_url_raw}" | LC_ALL=C tr -d '\r')"
           effective_url="$(printf "%s" "${effective_url}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')"
           # Remove any stray quotes/backticks anywhere to avoid parsing issues
           effective_url="${effective_url//\'/}"
           effective_url="${effective_url//\"/}"
           effective_url="${effective_url//\`/}"
+          if [ -z "${effective_url}" ]; then
+            echo "Error: MATCH_GIT_URL is empty."
+            echo "Set Actions variable MATCH_GIT_URL to the SSH URL (e.g., git@github.com:owner/repo.git), or set secret MATCH_GIT_URL."
+            exit 1
+          fi

          echo "Checking access to certs repo: ${effective_url}"

          # Show loaded identities and probe GitHub SSH (for diagnostics)
          echo "Loaded SSH identities:" && ssh-add -l || true
          echo "Probing GitHub SSH..." && ssh -T -o StrictHostKeyChecking=no git@github.com || true

          # Try SSH access (verbose)
          if GIT_SSH_COMMAND="ssh -o StrictHostKeyChecking=no -o IdentitiesOnly=yes -v" git ls-remote "${effective_url}" >/dev/null 2>&1; then
            echo "Access OK via SSH."
          else
            echo "Error: Cannot access certificates repo via ${effective_url}."
            echo "Ensure MATCH_GIT_URL points to the certificates repo SSH URL and MATCH_GIT_PRIVATE_KEY matches its Deploy Key fingerprint (with write access)."
            exit 1
          fi

          if [[ "${readonly_flag}" == "true" ]]; then
            echo "Readonly mode enabled: CI will NOT create certificates/profiles."
            echo "Ensure the certificates repo already contains distribution certs and app-store profiles."
          else
            echo "Readonly=false: CI will attempt to create certificates/profiles (requires Admin role)."
          fi

      - name: Build and Upload to TestFlight
        run: bundle exec fastlane --verbose beta