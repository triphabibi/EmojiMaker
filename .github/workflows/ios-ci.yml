name: iOS CI - Build and TestFlight

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  build-and-upload:
    runs-on: macos-latest
    env:
      MATCH_GIT_URL: ${{ secrets.MATCH_GIT_URL }}
      MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
      APPLE_ID: ${{ secrets.APPLE_ID }}
      TEAM_ID: ${{ secrets.TEAM_ID }}
      APP_IDENTIFIER: ${{ secrets.APP_IDENTIFIER }}
      APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
      APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
      APP_STORE_CONNECT_KEY: ${{ secrets.APP_STORE_CONNECT_KEY }}
      # Optional auth mechanisms for private match repo
      MATCH_GIT_PRIVATE_KEY: ${{ secrets.MATCH_GIT_PRIVATE_KEY }}
      MATCH_GIT_PRIVATE_KEY_B64: ${{ secrets.MATCH_GIT_PRIVATE_KEY_B64 }}
      MATCH_GIT_TOKEN: ${{ secrets.MATCH_GIT_TOKEN }}
      MATCH_READONLY: ${{ secrets.MATCH_READONLY }}
      FASTLANE_SKIP_UPDATE_CHECK: true
      FASTLANE_VERBOSE: 1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.2'
          bundler-cache: true

      - name: Install Homebrew dependencies
        run: |
          brew update
          brew install xcodegen

      - name: Generate Xcode project
        run: xcodegen generate

      - name: Show Xcode version
        run: xcodebuild -version

      - name: Install gems
        run: bundle install --path vendor/bundle

      - name: Configure Git auth for match repo (HTTPS token)
        if: ${{ env.MATCH_GIT_TOKEN != '' }}
        run: |
          git config --global url."https://${{ env.MATCH_GIT_TOKEN }}@github.com/".insteadOf "https://github.com/"

      - name: Prepare SSH key from secret
        if: ${{ env.MATCH_GIT_PRIVATE_KEY != '' || env.MATCH_GIT_PRIVATE_KEY_B64 != '' }}
        id: prep_match_key
        shell: bash
        run: |
          # Prefer base64 secret if provided to avoid newline/encoding issues
          if [ -n "${{ env.MATCH_GIT_PRIVATE_KEY_B64 }}" ]; then
            echo "Using base64-encoded private key secret"
            KEY="$(echo "${{ env.MATCH_GIT_PRIVATE_KEY_B64 }}" | base64 --decode | LC_ALL=C tr -d '\r')"
          else
            KEY="${{ env.MATCH_GIT_PRIVATE_KEY }}"
            # If the secret is single-line with literal \n, convert to real newlines
            if echo "$KEY" | grep -q '\\n'; then
              KEY="$(printf "%b" "$KEY")"
            fi
            # Normalize Windows CRLF to LF (force C locale to avoid encoding issues)
            KEY="$(echo "$KEY" | LC_ALL=C tr -d '\r')"
            # If header missing, try base64-decode fallback
            if ! echo "$KEY" | grep -Eq 'BEGIN (OPENSSH|RSA) PRIVATE KEY'; then
              if echo "$KEY" | base64 --decode > /tmp/match_key_decoded 2>/dev/null; then
                # Use LC_ALL=C to avoid illegal byte sequence errors
                KEY="$(cat /tmp/match_key_decoded | LC_ALL=C tr -d '\r')"
              else
                echo 'Note: Private key header missing and base64 decode failed. Ensure the secret contains the FULL private key.'
              fi
            fi
          fi

          # Reject PuTTY .ppk format explicitly
          if echo "$KEY" | head -n1 | grep -q 'PuTTY-User-Key-File-'; then
            echo 'Error: Detected PuTTY .ppk format. Export OpenSSH private key via PuTTYgen (Conversions â†’ Export OpenSSH key (new)).'
            exit 1
          fi

          # Log detected key header type (no secret content is printed)
          if echo "$KEY" | grep -q 'BEGIN OPENSSH PRIVATE KEY'; then
            echo 'Detected OpenSSH private key.'
          elif echo "$KEY" | grep -q 'BEGIN RSA PRIVATE KEY'; then
            echo 'Detected PEM RSA private key.'
          else
            echo 'Warning: No recognized private key header found.'
          fi

          # Emit processed key as output (multi-line)
          {
            echo 'key<<EOF'
            echo "$KEY"
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Start ssh-agent and add match deploy key
        if: ${{ env.MATCH_GIT_PRIVATE_KEY != '' || env.MATCH_GIT_PRIVATE_KEY_B64 != '' }}
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ steps.prep_match_key.outputs.key }}

      - name: Add GitHub to known_hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          echo "SSH agent ready; using $MATCH_GIT_URL"

      - name: "Preflight: verify certs repo access and readonly mode"
        shell: bash
        run: |
          readonly_flag="${MATCH_READONLY:-true}"
          echo "Match readonly: ${readonly_flag}"

          # Decide auth mode: prefer SSH if a private key is provided
          auth_mode="auto"
          if [[ -n "${MATCH_GIT_PRIVATE_KEY}" || -n "${MATCH_GIT_PRIVATE_KEY_B64}" ]]; then
            auth_mode="ssh"
          elif [[ -n "${MATCH_GIT_TOKEN}" ]]; then
            auth_mode="https"
          else
            auth_mode="none"
          fi
          echo "Preflight auth mode: ${auth_mode}"

          effective_url="${MATCH_GIT_URL}"
          if [[ "${auth_mode}" == "https" && "${effective_url}" =~ ^git@github.com: ]]; then
            # Rewrite SSH URL to HTTPS for token usage only if SSH not configured
            effective_url="https://github.com/${effective_url#git@github.com:}"
          fi

          echo "Checking access to certs repo: ${effective_url}"
          # Rely on previous global git config rewrite (for HTTPS) or ssh-agent (for SSH) for authentication
          if ! git ls-remote "${effective_url}" &>/dev/null; then
            echo "Error: Cannot access certificates repo via ${effective_url}."
            if [[ "${auth_mode}" == "https" ]]; then
              echo "If using HTTPS, ensure MATCH_GIT_TOKEN has access to the repo (fine-grained: 'Contents: Read', classic: 'repo')."
            elif [[ "${auth_mode}" == "ssh" ]]; then
              echo "If using SSH, ensure MATCH_GIT_PRIVATE_KEY corresponds to a Deploy Key with access to this repo."
            else
              echo "No auth configured: set either MATCH_GIT_TOKEN (HTTPS) or MATCH_GIT_PRIVATE_KEY / MATCH_GIT_PRIVATE_KEY_B64 (SSH)."
            fi
            exit 1
          fi

          if [[ "${readonly_flag}" == "true" ]]; then
            echo "Readonly mode enabled: CI will NOT create certificates/profiles."
            echo "Ensure the certificates repo already contains distribution certs and app-store profiles."
          else
            echo "Readonly=false: CI will attempt to create certificates/profiles (requires Admin role)."
          fi

      - name: Build and Upload to TestFlight
        run: bundle exec fastlane --verbose beta